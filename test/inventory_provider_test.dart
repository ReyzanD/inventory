import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:inventory/providers/inventory_provider.dart';
import 'package:inventory/models/inventory_item.dart';
import 'package:inventory/models/product.dart';
import 'package:inventory/models/inventory_notification.dart';
import 'package:inventory/services/inventory_service.dart';
import 'inventory_provider_test.mocks.dart'; // Generated by mockito

@GenerateMocks([InventoryService])
void main() {
  late InventoryProvider provider;
  late MockInventoryService mockService;
  
  // Sample test data
  final testInventoryItem = InventoryItem(
    id: '1',
    name: 'Test Item',
    description: 'Test Description',
    quantity: 10.0,
    unit: 'kg',
    costPerUnit: 2.0,
    sellingPricePerUnit: 3.0,
    dateAdded: DateTime.now(),
    category: 'Test Category',
  );
  
  final testProduct = Product(
    id: '1',
    name: 'Test Product',
    description: 'Test Product Description',
    sellingPrice: 15.0,
    components: [
      ProductComponent(
        inventoryItemId: '1',
        quantityNeeded: 2.0,
        unit: 'kg',
      ),
    ],
    dateCreated: DateTime.now(),
    category: 'Test Category',
  );
  
  setUp(() async {
    mockService = MockInventoryService();
    provider = InventoryProvider.forTesting(mockService);
    // Set up initial empty lists for all tests
    when(mockService.getAllInventoryItems()).thenAnswer((_) async => []);
    when(mockService.getAllProducts()).thenAnswer((_) async => []);
    await provider.loadInventoryItems();
    await provider.loadProducts();
  });

  group('InventoryProvider Tests', () {
    group('CRUD Operations - Inventory Items', () {
      test('should load inventory items', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]);
        
        await provider.loadInventoryItems();
        
        expect(provider.inventoryItems.length, 1);
        expect(provider.inventoryItems.first.name, 'Test Item');
      });
      
      test('should initialize with empty list when no items exist', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => []);
        
        await provider.loadInventoryItems();
        
        expect(provider.inventoryItems.isEmpty, true);
      });
      
      test('should add inventory item', () async {
        // Set up the mock to return [testInventoryItem] when getAllInventoryItems is called after the add
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]);

        await provider.addInventoryItem(testInventoryItem);

        verify(mockService.addInventoryItem(testInventoryItem)).called(1);
      });

      test('should update inventory item', () async {
        final updatedItem = testInventoryItem.copyWith(quantity: 15.0);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [updatedItem]);

        await provider.updateInventoryItem(updatedItem);

        verify(mockService.updateInventoryItem(updatedItem)).called(1);
      });

      test('should delete inventory item', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => []);

        await provider.deleteInventoryItem('1');

        verify(mockService.deleteInventoryItem('1')).called(1);
      });
      
      test('should return null for non-existent inventory item by ID', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => []);
        
        await provider.loadInventoryItems();
        
        final result = provider.getInventoryItemById('nonexistent');
        expect(result, isNull);
      });
      
      test('should find existing inventory item by ID', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]);
        
        await provider.loadInventoryItems();
        
        final result = provider.getInventoryItemById('1');
        expect(result, isNotNull);
        expect(result!.id, '1');
      });
    });
    
    group('CRUD Operations - Products', () {
      test('should load products', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => [testProduct]);
        
        await provider.loadProducts();
        
        expect(provider.products.length, 1);
        expect(provider.products.first.name, 'Test Product');
      });
      
      test('should initialize with empty list when no products exist', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => []);
        
        await provider.loadProducts();
        
        expect(provider.products.isEmpty, true);
      });
      
      test('should add product', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => [testProduct]);

        await provider.addProduct(testProduct);

        verify(mockService.addProduct(testProduct)).called(1);
      });

      test('should update product', () async {
        final updatedProduct = Product(
          id: '1',
          name: 'Updated Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: '1',
              quantityNeeded: 2.0,
              unit: 'kg',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        when(mockService.getAllProducts()).thenAnswer((_) async => [updatedProduct]);

        await provider.updateProduct(updatedProduct);

        verify(mockService.updateProduct(updatedProduct)).called(1);
      });

      test('should delete product', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => []);

        await provider.deleteProduct('1');

        verify(mockService.deleteProduct('1')).called(1);
      });
    });
    
    group('Notification Checking Logic', () {
      test('should generate low stock notification when quantity <= 5', () async {
        final lowStockItem = testInventoryItem.copyWith(quantity: 3.0);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [lowStockItem]);
        
        await provider.loadInventoryItems();
        await provider.checkNotifications();
        
        expect(provider.notifications.length, 1);
        expect(provider.notifications.first.type, NotificationType.lowStock);
        expect(provider.notifications.first.title, 'Low Stock Alert');
      });
      
      test('should not generate low stock notification when quantity > 5', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]); // Default quantity is 10
        
        await provider.loadInventoryItems();
        await provider.checkNotifications();
        
        expect(provider.notifications.isEmpty, true);
      });
      
      test('should generate multiple low stock notifications', () async {
        final lowStockItem1 = testInventoryItem.copyWith(id: '1', quantity: 2.0, name: 'Item 1');
        final lowStockItem2 = testInventoryItem.copyWith(id: '2', quantity: 4.0, name: 'Item 2');
        final sufficientStockItem = testInventoryItem.copyWith(id: '3', quantity: 10.0, name: 'Item 3');
        
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [
          lowStockItem1,
          lowStockItem2,
          sufficientStockItem,
        ]);
        
        await provider.loadInventoryItems();
        await provider.checkNotifications();
        
        expect(provider.notifications.length, 2);
        expect(provider.notifications.every((n) => n.type == NotificationType.lowStock), true);
      });
      
      test('should clear notifications when reloading with sufficient stock', () async {
        final lowStockItem = testInventoryItem.copyWith(quantity: 3.0);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [lowStockItem]);
        
        await provider.loadInventoryItems();
        await provider.checkNotifications();
        expect(provider.notifications.length, 1);
        
        final sufficientStockItem = testInventoryItem.copyWith(quantity: 10.0);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [sufficientStockItem]);
        
        await provider.loadInventoryItems();
        await provider.checkNotifications();
        
        expect(provider.notifications.isEmpty, true);
      });
    });
    
    group('Inventory Reduction Logic', () {
      test('should reduce inventory when selling a product', () async {
        final inventoryItemWithSufficientStock = testInventoryItem.copyWith(quantity: 10.0);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [inventoryItemWithSufficientStock]);
        when(mockService.getAllProducts()).thenAnswer((_) async => [testProduct]);
        
        await provider.loadInventoryItems();
        await provider.loadProducts();
        
        // Before reduction
        expect(provider.inventoryItems.first.quantity, 10.0);
        
        await provider.reduceInventoryForSoldProduct('1');
        
        // After reduction - the component needs 2.0 kg, so new quantity should be 8.0
        verify(mockService.updateInventoryItem(any)).called(1);
      });
      
      test('should not reduce inventory if product does not exist', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]);
        when(mockService.getAllProducts()).thenAnswer((_) async => []);
        
        await provider.loadInventoryItems();
        await provider.loadProducts();
        
        await provider.reduceInventoryForSoldProduct('nonexistent');
        
        // Should not update any inventory items if product doesn't exist
        verifyNever(mockService.updateInventoryItem(any));
      });
      
      test('should handle unit conversion properly during inventory reduction', () async {
        final kgInventoryItem = testInventoryItem.copyWith(
          id: '1',
          quantity: 1.0, // 1kg
          unit: 'kg',
        );
        
        final productWithGComponents = Product(
          id: '1',
          name: 'Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: '1',
              quantityNeeded: 500.0, // 500g
              unit: 'g',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [kgInventoryItem]);
        when(mockService.getAllProducts()).thenAnswer((_) async => [productWithGComponents]);
        
        await provider.loadInventoryItems();
        await provider.loadProducts();
        
        await provider.reduceInventoryForSoldProduct('1');
        
        // 500g from 1kg should leave 0.5kg (since 500g = 0.5kg)
        verify(mockService.updateInventoryItem(any)).called(1);
      });
      
      test('should not reduce inventory for non-existent inventory items in product components', () async {
        final productWithNonExistentComponent = Product(
          id: '1',
          name: 'Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: 'nonexistent',
              quantityNeeded: 2.0,
              unit: 'kg',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]);
        when(mockService.getAllProducts()).thenAnswer((_) async => [productWithNonExistentComponent]);
        
        await provider.loadInventoryItems();
        await provider.loadProducts();
        
        // This should not throw an exception and should continue processing
        await provider.reduceInventoryForSoldProduct('1');
        
        // Should not update the existing item since the referenced component doesn't exist
        verifyNever(mockService.updateInventoryItem(any));
      });
    });
    
    group('Edge Cases', () {
      test('should handle empty inventory items list', () async {
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => []);
        
        await provider.loadInventoryItems();
        
        expect(provider.inventoryItems.isEmpty, true);
        expect(provider.getInventoryItemById('any_id'), isNull);
      });
      
      test('should handle empty products list', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => []);
        
        await provider.loadProducts();
        
        expect(provider.products.isEmpty, true);
      });
      
      test('should handle invalid product ID gracefully', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => [testProduct]);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]);
        
        await provider.loadProducts();
        await provider.loadInventoryItems();
        
        // Should not crash with invalid product ID
        await provider.reduceInventoryForSoldProduct('invalid_id');
      });
      
      test('should calculate COGS as zero for non-existent product', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => []);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => []);

        await provider.loadProducts();
        await provider.loadInventoryItems();

        double cogs = provider.calculateProductCogs('nonexistent');
        expect(cogs, 0.0);
      });

      test('should handle negative quantities gracefully', () async {
        final negativeItem = InventoryItem(
          id: '2',
          name: 'Negative Item',
          description: 'Test Description',
          quantity: -5.0,  // negative quantity
          unit: 'kg',
          costPerUnit: 2.0,
          sellingPricePerUnit: 3.0,
          dateAdded: DateTime.now(),
          category: 'Test Category',
        );

        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [negativeItem]);
        when(mockService.updateInventoryItem(any)).thenAnswer((_) async => true);

        await provider.loadInventoryItems();
        expect(provider.inventoryItems.first.quantity, -5.0);

        // Test that negative quantities don't break calculations
        expect(provider.inventoryItems.first.totalCost, -10.0); // -5.0 * 2.0
      });

      test('should handle very large quantity values', () async {
        final largeQuantityItem = InventoryItem(
          id: '3',
          name: 'Large Quantity Item',
          description: 'Test with large quantity',
          quantity: 999999999.99,  // very large value
          unit: 'pcs',
          costPerUnit: 1.0,
          sellingPricePerUnit: 2.0,
          dateAdded: DateTime.now(),
          category: 'Test Category',
        );

        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [largeQuantityItem]);

        await provider.loadInventoryItems();
        expect(provider.inventoryItems.first.quantity, 999999999.99);
      });

      test('should handle boundary condition where quantity equals low stock threshold', () async {
        final boundaryItem = InventoryItem(
          id: '4',
          name: 'Boundary Item',
          description: 'Item at threshold',
          quantity: 5.0,  // equals default threshold
          unit: 'pcs',
          costPerUnit: 1.0,
          sellingPricePerUnit: 2.0,
          dateAdded: DateTime.now(),
          category: 'Test Category',
          lowStockThreshold: 5.0,  // same as quantity
        );

        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [boundaryItem]);

        await provider.loadInventoryItems();
        // Should trigger low stock notification when quantity equals or is below threshold
        final lowStockItems = provider.inventoryItems.where((item) => item.quantity <= item.lowStockThreshold).toList();
        expect(lowStockItems.length, 1);  // Boundary condition: should be included
      });

      test('should handle empty string values gracefully', () async {
        final emptyStringItem = InventoryItem(
          id: '5',
          name: '',  // empty name
          description: '',  // empty description
          quantity: 10.0,
          unit: '',  // empty unit
          costPerUnit: 1.0,
          sellingPricePerUnit: 2.0,
          dateAdded: DateTime.now(),
          category: '',  // empty category
        );

        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [emptyStringItem]);

        await provider.loadInventoryItems();
        expect(provider.inventoryItems.first.name, '');
        expect(provider.inventoryItems.first.category, '');
        expect(provider.inventoryItems.first.unit, '');
      });

      test('should handle null values gracefully', () async {
        final nullValuesItem = InventoryItem(
          id: '6',
          name: 'Test Item',
          description: 'Test Description',
          quantity: 10.0,
          unit: 'pcs',
          costPerUnit: 1.0,
          sellingPricePerUnit: 2.0,
          dateAdded: DateTime.now(),
          category: 'Test Category',
        );

        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [nullValuesItem]);
        await provider.loadInventoryItems();

        // Test with null ID - should return null
        expect(provider.getInventoryItemById('nonexistent'), isNull);
      });

      test('should handle boundary condition where quantity is exactly at low stock threshold', () async {
        final boundaryItem = InventoryItem(
          id: '7',
          name: 'Boundary Test Item',
          description: 'Item at threshold',
          quantity: 5.0, // Exactly at default low stock threshold
          unit: 'pcs',
          costPerUnit: 2.0,
          sellingPricePerUnit: 3.0,
          dateAdded: DateTime.now(),
          category: 'Boundary Category',
        );

        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [boundaryItem]);
        await provider.loadInventoryItems();

        // Should recognize as low-stock when quantity equals threshold
        final lowStockItems = provider.inventoryItems
            .where((item) => item.quantity <= item.lowStockThreshold)
            .toList();
        expect(lowStockItems.length, 1); // Should include item when quantity equals threshold
      });
    });

    group('Check Inventory Availability', () {
      test('should check if product exists for inventory availability', () async {
        when(mockService.getAllProducts()).thenAnswer((_) async => []);

        await provider.loadProducts();

        bool hasInventory = provider.hasEnoughInventoryForProduct('nonexistent');
        expect(hasInventory, false);
      });
    });
    
    group('Calculate COGS Logic', () {
      test('should calculate correct COGS for a product', () async {
        final inventoryItem = testInventoryItem.copyWith(costPerUnit: 2.0);
        final product = Product(
          id: '1',
          name: 'Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: '1',
              quantityNeeded: 2.0,
              unit: 'kg',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        
        when(mockService.getAllProducts()).thenAnswer((_) async => [product]);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [inventoryItem]);
        
        await provider.loadProducts();
        await provider.loadInventoryItems();
        
        double cogs = provider.calculateProductCogs('1');
        // 2.0 units * 2.0 cost per unit = 4.0 COGS
        expect(cogs, 4.0);
      });
      
      test('should calculate COGS considering unit conversions', () async {
        final kgInventoryItem = testInventoryItem.copyWith(
          id: '1',
          quantity: 1.0,
          unit: 'kg',
          costPerUnit: 5.0, // 5 per kg
        );
        
        final productWithGComponents = Product(
          id: '1',
          name: 'Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: '1',
              quantityNeeded: 500.0, // 500g
              unit: 'g',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        
        when(mockService.getAllProducts()).thenAnswer((_) async => [productWithGComponents]);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [kgInventoryItem]);
        
        await provider.loadProducts();
        await provider.loadInventoryItems();
        
        double cogs = provider.calculateProductCogs('1');
        // 500g = 0.5kg, so 0.5 * 5.0 = 2.5 COGS
        expect(cogs, 2.5);
      });
    });
    
    group('Check Inventory Availability', () {
      test('should return true if product has enough inventory', () async {
        final inventoryItem = testInventoryItem.copyWith(quantity: 10.0);
        final product = Product(
          id: '1',
          name: 'Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: '1',
              quantityNeeded: 5.0,
              unit: 'kg',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        
        when(mockService.getAllProducts()).thenAnswer((_) async => [product]);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [inventoryItem]);
        
        await provider.loadProducts();
        await provider.loadInventoryItems();
        
        bool hasInventory = provider.hasEnoughInventoryForProduct('1');
        expect(hasInventory, true);
      });
      
      test('should return false if product does not have enough inventory', () async {
        final lowInventoryItem = testInventoryItem.copyWith(quantity: 3.0);
        final product = Product(
          id: '1',
          name: 'Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: '1',
              quantityNeeded: 5.0,
              unit: 'kg',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        
        when(mockService.getAllProducts()).thenAnswer((_) async => [product]);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [lowInventoryItem]);
        
        await provider.loadProducts();
        await provider.loadInventoryItems();
        
        bool hasInventory = provider.hasEnoughInventoryForProduct('1');
        expect(hasInventory, false);
      });
      
      test('should return false if component inventory item does not exist', () async {
        final product = Product(
          id: '1',
          name: 'Test Product',
          description: 'Test Product Description',
          sellingPrice: 15.0,
          components: [
            ProductComponent(
              inventoryItemId: 'nonexistent',
              quantityNeeded: 5.0,
              unit: 'kg',
            ),
          ],
          dateCreated: DateTime.now(),
          category: 'Test Category',
        );
        
        when(mockService.getAllProducts()).thenAnswer((_) async => [product]);
        when(mockService.getAllInventoryItems()).thenAnswer((_) async => [testInventoryItem]);
        
        await provider.loadProducts();
        await provider.loadInventoryItems();
        
        bool hasInventory = provider.hasEnoughInventoryForProduct('1');
        expect(hasInventory, false);
      });
    });
  });
}

// Extension to allow copying InventoryItem with new values
extension InventoryItemX on InventoryItem {
  InventoryItem copyWith({
    String? id,
    String? name,
    String? description,
    double? quantity,
    String? unit,
    double? costPerUnit,
    double? sellingPricePerUnit,
    DateTime? dateAdded,
    String? category,
  }) {
    return InventoryItem(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      quantity: quantity ?? this.quantity,
      unit: unit ?? this.unit,
      costPerUnit: costPerUnit ?? this.costPerUnit,
      sellingPricePerUnit: sellingPricePerUnit ?? this.sellingPricePerUnit,
      dateAdded: dateAdded ?? this.dateAdded,
      category: category ?? this.category,
    );
  }
}